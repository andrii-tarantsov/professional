1. В начале интервью растерялся и не мог ответить на простой вопрос о том как обеспечить чтобы списанные с одного счета деньги гарантированно оказались на другом. Не рассказал об ACID транзакциях. Искал подвох и двойное дно в вопросе, а интервьюеры, скорее всего ожидали ответ об основном свойстве транзакций - атомарности, которое предполагает что все изменения данных с рамках одной транзакции будут или закоммичены (commit) вместе или все откачены (rollback).
2. После первого вопроса был неуверен и растерялся когда отвечал на второй. Когда спросили о проблемах с многопоточностью, запутался и начал рассказывать про кейсы, когда может произойти LazyInitializationException, хотя сначала хотел рассказать про ConcurrentModifiacationException. Естественно интервьюеры были изумлены, так как такой мой ответ прозвучал как полная чушь. Однажды, много лет назад, я решал в одном проекте ряд проблем и в частности была проблема когда коллекцию хотели пройти за пределами hibernate сессии, и другая проблема когда такая коллекция зависимых сущностей шарилась между потоками и непредсказуемо ломалась в процессе обхода итератором,  и поэтому у меня перепутались в голове рассказы. Когда я понял что сказал чушь, то растерялся еще больше.
3. О задаче с последовательной обработкой тасков. Когда есть входящий поток данных, и нужно распараллелить их обработку на несколько потоков, но потом результаты работы каждого потока обрабатывать дальше снова в том же порядке, в котором поступали исходные данные. Отличный вопрос, но я ответил невнятно одним словом очередь и не доформулировал толком свою мысль. Идея была в том что входящие данные из стрима хватают обрабатывать потоки из пула, а результат работы -  Future, мы сразу же складываем в Queue. В том же порядке, в котором поступают данные. Future из очереди забираются потом одним потоком. Он получает их, и блокируется на get, если очередной результат еще не готов. Я потом попробовал реализовать это - идея работает. Правда потоки я запускаю все-таки вручную как Callable из экзекьютора, а, судя по всему, интервьюеры,  ожидали решение построенное полностью на CompletableFuture.
4. Прекрасный вопрос про аннотацию @Transactional на private методе. Я когда позже тем вечером поразмыслил над ним и понял всю его прелесть,то пришел в восторг. Одним вопросом можно понять всю глубину понимания соискателем того как устроен весть Spring - все проксирование, AOP, dependency injection. Конечно спринг сам не будет проксировать приватные методы, так как в этом нет смысла - проксируются, бины, которые инжектятся в другие как депенденси.
5. Не знал о существовании составных индексов для в не_Oracle базах. Проверил, убедился что и в Postgre и в MySQL таки есть. Взял на заметку.
6. На вопрос "а почему бы и не создать индексы на все атрибуты в таблице?, не смог объяснить мысль что не нужно это делать, хотя бы потому, что перестроить индекс занимает время и в случае частой вставки новых записей или апейтов занчений проиндексированных атрибутов, наша база будет только тем и заниматься что перестраивать индексы.
7. В вопросе про индекс по male/female аттрибуту забыл как называется Bitmap индекс.
8. Не мог рассказать о том как в Java обеспечивается многопоточность с точки зрения JMM. Читал 17 лет назад. Спасибо за урок. Нужно выучить как стишок Пушкина.
9. Про Mockito и Spring Test Framework вообще не был готов ответить на вопрос. Рылся в памяти в поисках ответа на вопрос о том как зафиксировать с какими параметрами был вызван метод мока в Мокито. Пыжился припомнить, что была за аннотация с классом начинанающимся на “A”.  Потом проверил - хотел рассказать про аннтоцию Captor, а “A”   вспомнилась из за класса ArgumentCaptor. Но фактически был к этому вопросу не готов.
10. В основном на остальные вопросы отвечал чаще правильно, но общий фон был унылый. Из за того что после первых двух неудачных ответов расстроился и потом чувствовал себя неуверенно и тупил даже на те вопросы, которые знал.
